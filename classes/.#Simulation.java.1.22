/*
 * Copyright (c) 2005 Your Corporation. All Rights Reserved.
 */

import java.io.*;
import java.text.NumberFormat;
import java.util.*;

public class Simulation {

    protected static double vita;
    protected static double delta;
    protected static int incubation;
    protected static int maxIterationNumber;
    protected static int numOfSusceptible = 0;
    protected static int numOfInfected = 0;
    protected static int numOfImmune = 0;
    protected static int numOfVertices = 0;
    protected static int numOfInitialInfected = 0;
    protected static long seed = 0;

    static double tempRate = 0;
    static double averageRate = 0;

    protected static boolean selfdestruct = false;

    //Time related variables
    static final int HOURS_PER_DAY = 24;
    static final int MINUTES_PER_HOUR = 60;
    static final int SECONDS_PER_MINUTE = 60;
    static final int MILLISECONDS_PER_SECOND = 1000;

    static String debugFileName;
    static String plotFileName;
    static String splotFileName;
    static String statisticsFileName;
    static String verifyResultsFileName;
    static String checkVirusFileName;
    static String infectionProgressFileName;
    static String rateFileName;
    static String classType;
    static String[] sa;
    static String outputsFilePath = "../other/";


    static Random rgenerator;
    
    
    /**
     * Set the birth rate of the worm during the simulation process
     */
    protected static void setVita(double v) {
        Simulation.vita = v;
    }

    /**
     * Get  the birth rate of the worm during the simulation process
     */
    protected static double getVita() {
        return Simulation.vita;
    }


    /**
     * Set the maximum nuber of time slots (simulation cycles) for the simulation process
     */
    protected static void setMaxIterationNumber(int m) {
        Simulation.maxIterationNumber = m;
    }


    /**
     * Get the maximum nuber of time slots (simulation cycles) for the simulation process
     */
    protected static int getMaxIterationNumber() {
        return Simulation.maxIterationNumber;
    }

    /*
     *Set the incubation parameter (E in most epidimiological models) for  the simulation process
     */
    protected static void setEnviromentaltIncubation(int incub) {
        Simulation.incubation = incub;
    }

    /*
     *Get the incubation parameter (E in most epidimiological models) for  the simulation process
     */
    protected static int getEnviromentaltIncubation() {
        return (Simulation.incubation);
    }


    /*
     *Set the number of the susceptible population
     */
    protected static void setNumberOfSusceptible(int s) {
        Simulation.numOfSusceptible = s;
    }

    /*
     *Get the number of the susceptible population
     */
    protected static int getNumberOfSusceptible() {
        return (Simulation.numOfSusceptible);
    }


    /*
     *Decrease by one the number of the susceptible population.
     *It is possible onty to leave from this stage
     */
    protected static void decreaseNumberOfSusceptible() {
        Simulation.numOfSusceptible--;
    }

    /*
     *Increase by one the number of the susceptible population.
     *For debugging
     */
    protected static void increaseNumberOfSusceptible() {
        Simulation.numOfSusceptible++;
    }

    /*
     *Set the number of the infected population
     */
    protected static void setNumberOfInfected(int inf) {
        Simulation.numOfInfected = inf;
    }

    /*
     *Get the number of the infected population
     */
    protected static int getNumberOfInfected() {
        return (Simulation.numOfInfected);
    }

    /*
     *Set the number of the initial infected population
     */
    protected static void setNumberOfInitialInfected(int inInf) {
        Simulation.numOfInitialInfected = inInf;
    }

    /*
     *Get the number of the initial infected population
     */
    protected static int getNumberOfInitialInfected() {
        return (Simulation.numOfInitialInfected);
    }
    
    /*
     *Increase by one  number of the infected population
     */
    protected static void increaseNumberOfInfected() {
        Simulation.numOfInfected++;
    }

    /*
     *Decrease by one  the number of the infected population
     */
    protected static void decreaseNumberOfInfected() {
        Simulation.numOfInfected--;
    }

    /*
    *Set the number of the immune population
    */
    protected static void setNumberOfImune(int im) {
        Simulation.numOfImmune = im;
    }

    /*
    *Get the number of the infected population
    */
    protected static int getNumberOfImmune() {
        return (Simulation.numOfImmune);
    }

    /*
    *Increase by one the number of the infected population
    */
    protected static void increaseNumberOfImmune() {
        Simulation.numOfImmune++;
    }


    protected static boolean getSelfdestruct() {
        return (Simulation.selfdestruct);
    }
    
    

    protected static void setSelfdestruct(boolean b) {
        Simulation.selfdestruct = b;
    }

    protected static void setNumOfVertices(int inf) {
        Simulation.numOfVertices = inf;
    }

    protected static int getNumOfVertices() {
        return (Simulation.numOfVertices);
    }
    
     /*
        **FEED METHODS FOR VIRUSES--NUMBER OF NODES IS SPECIFIED BY THE USER AND ALSO WHO ARE THEY***
 */

    public static void virusFeeder(Graph generalGraph) {
        String tmp;
        String t;
        int nodeIndex;
        int numOfInfNodes;
        Node nameOfNode;
        int NumOfVertices = Simulation.getNumOfVertices();

        do {
            System.out.println("Please enter the number of the preinfected nodes: ");
            tmp = SimpleIO.readLine();
            numOfInfNodes = Integer.parseInt(tmp);
        } while (numOfInfNodes >= NumOfVertices);
        //Simulation.setNumOFinitialInfected(numOfInfNodes);

        for (int i = 0; i < numOfInfNodes; i++) {
            do {
                System.out.println("Enter the preinfected node: ");
                t = SimpleIO.readLine();
                nodeIndex = Integer.parseInt(t);
            } while (nodeIndex >= NumOfVertices);

            nameOfNode = generalGraph.getVertex(nodeIndex);
            System.out.println(nameOfNode);

            nameOfNode.setInfected();
            Simulation.decreaseNumberOfSusceptible();
            Simulation.increaseNumberOfInfected();
            //missing some control code to avoid infect already infected nodes
        }
    }

    /*
       **FEED METHODS FOR VIRUSES--NUMBER OF NODES IS SPECIFIED BY THE USER BUT THEY ARE RANDOMLY SELECTED***
     */

    public static void semiRandomVirusFeeder(Graph generalGraph, int ininfe) {
        String tmp;
        int nodeIndex;
        int numOfInfNodes;
        Integer nodeInteger;
        Node nameOfNode;
        int NumOfVertices;
        Vector v;
        boolean found;

        NumOfVertices = Simulation.getNumOfVertices();
        v = new Vector();

        if (ininfe == 0) {
            do {
                System.out.println("Please enter the number of the preinfected nodes: ");
                tmp = SimpleIO.readLine();
                numOfInfNodes = Integer.parseInt(tmp);
            } while (numOfInfNodes >= NumOfVertices);
        } else {
            numOfInfNodes = ininfe;
        }


        while (v.size() <= numOfInfNodes) {
            found = false;
            nodeIndex = (int) (NumOfVertices * rgenerator.nextDouble());
            if (v.size() == 0) {
                v.addElement(new Integer(nodeIndex));
                continue;
            }
            for (int e = 0; e < v.size(); e++) {
                nodeInteger = (Integer) (v.elementAt(e));
                if (nodeIndex == (nodeInteger.intValue())) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                v.addElement(new Integer(nodeIndex));
                nameOfNode = generalGraph.getVertex(nodeIndex);
                nameOfNode.setInfected();
                Simulation.decreaseNumberOfSusceptible();
                Simulation.increaseNumberOfInfected();
                System.out.println("Infecting node: " + nodeIndex);
                System.out.println("Current Number of Infected:= " + Simulation.getNumberOfInfected());
            }
        }
    }

    /*
      **FEED METHOD FOR VIRUSES--NUMBER OF NODES AND WHO THEY ARE, ARE RANDOMLY SELECTED***
      */

    public static void randomVirusFeeder(Graph generalGraph) {
        int numOfInfNodes;
        int nodeIndex;
        Integer nodeInteger;
        Node nameOfNode;
        Vector v;
        boolean found;
        int NumOfVertices = Simulation.getNumOfVertices();

        System.out.println("Number of Vertices" + NumOfVertices);

        v = new Vector();
        numOfInfNodes = (int) (NumOfVertices * rgenerator.nextDouble());

        //Simulation.setNumOFinitialInfected(numOfInfNodes);
        System.out.println("Number of the preinfected nodes: " + numOfInfNodes);

        while (v.size() <= numOfInfNodes) {
            found = false;
            nodeIndex = (int) (NumOfVertices * rgenerator.nextDouble());
            if (v.size() == 0) {
                v.addElement(new Integer(nodeIndex));
                continue;
            }
            for (int e = 0; e < v.size(); e++) {
                nodeInteger = (Integer) (v.elementAt(e));
                if (nodeIndex == (nodeInteger.intValue())) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                v.addElement(new Integer(nodeIndex));
                nameOfNode = generalGraph.getVertex(nodeIndex);
                nameOfNode.setInfected();
                Simulation.decreaseNumberOfSusceptible();
                Simulation.increaseNumberOfInfected();
                System.out.println("Preinfected node=:\t" + nameOfNode);
            }
        }
    }


    /**
     * This method is used to check the above virus feeders methods and prints and prints results on screen
     * and on file (by returnig a string with the desirable info)!!
     */
    static String checkVirus(Graph generalGraph) {
            Node nameOfNode;
            System.out.println("Printing detailed information ");
            int NumOfVertices = Simulation.getNumOfVertices();
            String s = "\nPrinting detailed information \n";

            for (int i = 0; i < NumOfVertices; i++) {
                nameOfNode = generalGraph.getVertex(i);
                if (nameOfNode.checkSusceptible()) {
                    System.out.println("Node \t" + i + "\t susceptible =:" + nameOfNode.checkSusceptible());
                    s = s + "Node \t" + i + "\t susceptible =:" + nameOfNode.checkSusceptible();
                } else if (nameOfNode.checkInfected()) {
                    System.out.println("Node \t" + i + "\t infected =:" + nameOfNode.checkInfected());
                    s = s + "Node \t" + i + "\t infected =:" + nameOfNode.checkInfected();
                } else if (nameOfNode.checkImmune()) {
                    System.out.println("Node \t" + i + "\t immunized =:" + nameOfNode.checkImmune());
                    s = s + "Node \t" + i + "\t immunized =:" + nameOfNode.checkImmune();
                }

                if (nameOfNode.getIncubation() > 0) {
                    System.out.print("        **Incubation period:    " + nameOfNode.getIncubation());
                    System.out.println();
                    s = s + "        **Incubation period:    " + nameOfNode.getIncubation() + "\n";
                } else {
                    s = s + "\n";
                }
            }
            return s;
        }

    
    /**
     * Checking method that is used to verify the results of every iteration of aour simulation model)
     * and prints results on screen and on file (by returnig a string with the desirable info)
     */
    static String verifyResults() {

        int activeNodes;
        String s = "\n";

        activeNodes = Simulation.getNumberOfSusceptible() + Simulation.getNumberOfInfected() + Simulation.getNumberOfImmune();
        if (activeNodes != Simulation.getNumOfVertices()) {

            System.out.println("-----------------------------------------------------------------------------------------");
            s = s + "-----------------------------------------------------------------------------------------\n";
            System.out.println("CorruptedResults");
            s = s + "CorruptedResults\n";
            System.out.println("Active Nodes(Population):  " + activeNodes);
            s = s + "Active Nodes(Population):  " + activeNodes + "\n";
            System.out.println("Total Nodes(Population):   " + Simulation.getNumOfVertices());
            s = s + "Total Nodes(Population):   " + Simulation.getNumOfVertices() + "\n";
            s = s + "*Susceptible Nodes: " + Simulation.getNumberOfSusceptible() + "\n*Infected Nodes: " + Simulation.getNumberOfInfected() + "\n*Immune Nodes: " + Simulation.getNumberOfImmune();

        } else {
            System.out.println("-----------------------------------------------------------------------------------------");
            s = s + "-----------------------------------------------------------------------------------------\n";
            System.out.println("Results verified ");
            s = s + "Results verified \n";
            System.out.println("Active Nodes(Population):  " + activeNodes + " Total Nodes(Population):   " + Simulation.getNumOfVertices());
            s = s + "Active Nodes(Population):  " + activeNodes + " \tTotal Nodes(Population):   " + Simulation.getNumOfVertices() + "\n";
            s = s + "*Susceptible Nodes: " + Simulation.getNumberOfSusceptible() + "\nInfected Nodes: " + Simulation.getNumberOfInfected() + "\n*Immune Nodes: " + Simulation.getNumberOfImmune();
        }


        if (Simulation.getNumberOfInfected() == numOfVertices) {
            System.out.println("The whole  population is Infected---Terminating");
            s = s + "\nThe whole  population is Infected---Terminating\n";
            Simulation.setSelfdestruct(true);
        }
        return s;


    }


    static void calculateElapsedTime(long milliseconds) {
        /* value to break down into hours, minutes, seconds, milliseconds */
        long togo = milliseconds; /* milliseconds */

        int millis = (int) (togo % MILLISECONDS_PER_SECOND);
        /* /= is just shorthand for togo = togo / 1000 */
        togo /= MILLISECONDS_PER_SECOND;

        int seconds = (int) (togo % SECONDS_PER_MINUTE);
        togo /= SECONDS_PER_MINUTE;

        int minutes = (int) (togo % MINUTES_PER_HOUR);
        togo /= MINUTES_PER_HOUR;

        int hours = (int) (togo % HOURS_PER_DAY);
        int days = (int) (togo / HOURS_PER_DAY);

        System.out.println("Total computational time: " + days + "d  " + hours + "h  " + minutes + "m  " + seconds + "s  " + millis + "ms ");
    }


    /*
     *Checking method that counts total number of nodes with different states (infected, immune and susceptible)
     *and prints results on screen and on file (by returnig a string with the desirable info)
     */
    static String printStatistics() {

        String s = "\n";

        System.out.println("-----------------------------------------------------------------------------------------");
        s = s + "-----------------------------------------------------------------------------------------\n";
        System.out.println("Total number of  susceptible population:   " + Simulation.getNumberOfSusceptible());
        s = s + "Total number of  susceptible population:   " + Simulation.getNumberOfSusceptible() + "\n";
        System.out.println("Total number of  infected population:   " + Simulation.getNumberOfInfected());
        s = s + "Total number of  infected population:   " + Simulation.getNumberOfInfected() + "\n";
        System.out.println("Total number of  immune population:   " + Simulation.getNumberOfImmune());
        s = s + "Total number of  immune population:   " + Simulation.getNumberOfImmune() + "\n";
        System.out.println("Total population:  " + Simulation.getNumOfVertices());
        s = s + "Total population:  " + Simulation.getNumOfVertices() + "\n";
        System.out.println("-----------------------------------------------------------------------------------------");
        s = s + "-----------------------------------------------------------------------------------------\n";

        return s;

    }

    public static void decreaseNodeIncubation(Node n) {


        if (n.getIncubation() > 0) {
            n.decreaseIncubation();
        } else if (n.getIncubation() < 0) {
            System.err.println("Incubation below 0 - Error Code 2");
            System.exit(-1);
        }

    }



    public static void handleIncubation(Graph generalGraph) {
        Node nodeO;

        for (int o = 0; o < numOfVertices; o++) {
            int tempIncubation;

            nodeO = generalGraph.getVertex(o);
            if (nodeO.checkInfected()) {
                tempIncubation = nodeO.getIncubation();
                if (nodeO.getIncubation() > 0) {
                    nodeO.setIncubation(--tempIncubation);
                } else if (nodeO.getIncubation() < 0) {
                    System.err.println("Incubation below 0 - Error Code 4");
                    System.exit(-1);
                }
            } else {
                nodeO.setIncubation(0);
            }
        }
    }
    
    
    /**
     *Decrease the incubation of all infected nodes by 1. 
     **/
    public static void decreaseAllIncubation(Graph generalGraph) {
        Node nodeO;
                        
        try {
            for (int o = 0; o < numOfVertices; o++) {
                        nodeO = generalGraph.getVertex(o);
                        if (nodeO.checkInfected()) decreaseNodeIncubation(nodeO);
                    }
        
        } catch (Exception e) {
            System.err.println("Decrease all incubation");
        }
    }
    
    public static void writeData(String randomFileName, int k, double infectionRate, double grate, long startTimer) {
        int NumOfVertices = Simulation.getNumOfVertices();
        int initInfected = Simulation.getNumberOfInitialInfected();
        NumberFormat nf = NumberFormat.getInstance(Locale.US);
        long intermediate = System.currentTimeMillis();
        long duration = intermediate - startTimer;


        nf.setMaximumFractionDigits(5);
        nf.setMinimumFractionDigits(5);
        
        //Initializes variables for printing results on file
        try {
            
            verifyResultsFileName = outputsFilePath + "verification/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "VerifyResults.txt";
            FileWriter verifyResultsFile = new FileWriter(verifyResultsFileName, true);

            statisticsFileName = outputsFilePath + "statistics/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "PrintStatistcs.txt";
            FileWriter statisticsFile = new FileWriter(statisticsFileName, true);

            plotFileName = outputsFilePath + "/plots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Gplot.txt";
            FileWriter plotFile = new FileWriter(plotFileName, true);

            splotFileName = outputsFilePath + "/splots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Splot.txt";
            FileWriter splotFile = new FileWriter(splotFileName, true);

            rateFileName = outputsFilePath + "/plots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Rate.txt";
            FileWriter rateFile = new FileWriter(rateFileName, true);
            
            verifyResultsFile.write("\nSimulation Cycle: " + k + Simulation.verifyResults());
            statisticsFile.write("\nSimulation Cycle: " + k + Simulation.printStatistics());
            infectionRate = ((float) Simulation.getNumberOfInfected() / NumOfVertices);
            plotFile.write(k + "\t" + nf.format(infectionRate) +  "\n");  
            splotFile.write(k + "\t" + nf.format(infectionRate) + "\t" + (duration/1000) + "\n");
            rateFile.write(k + "\t" + nf.format(grate) +  "\n");
            statisticsFile.close();
            plotFile.close();
            splotFile.close();
            rateFile.close();
            
       } catch (IOException ioe) {
            System.err.println("Misbehavior of data files");
        }
                
    }
    
    
    /*
     *The main SI simulation model
     */
    public static void coreSusceptibleImmuneSimulationEngine(Graph generalGraph) {
        try {

            Node nodeI;
            Node nodeJ = null;
            double vita;
            double randomSample;
            double infectionRate = 0;
            long startTimer;
            long stoppedTimer;
            long duration;
            long intermediate;
            int numOfIterations;
            int vectorPos;
            int vectorSize;
            int NumOfVertices = Simulation.getNumOfVertices();
            int initInfected;
            int discretization = 5;
            int cycle;
            int tempDiscr = -1;
            int avgRate = 0;
            double grate = 0;
            int x = (int) (100 * Math.random());


            String randomFileName = String.valueOf(x);


            vita = Simulation.getVita();
            numOfIterations = Simulation.getMaxIterationNumber();
            initInfected = Simulation.getNumberOfInitialInfected();
            //initInfected = Simulation.getNumberOfInfected();
            Simulation.setNumberOfSusceptible((numOfVertices - initInfected));
            Simulation.setNumberOfInfected(initInfected);

            /*
             *Initializes variables for printing results on file
             **/
            verifyResultsFileName = outputsFilePath + "verification/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "VerifyResults.txt";
            FileWriter verifyResultsFile = new FileWriter(verifyResultsFileName);

            statisticsFileName = outputsFilePath + "statistics/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "PrintStatistcs.txt";
            FileWriter statisticsFile = new FileWriter(statisticsFileName);

            plotFileName = outputsFilePath + "/plots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Gplot.txt";
            FileWriter plotFile = new FileWriter(plotFileName);

            rateFileName = outputsFilePath + "/plots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Rate.txt";
            FileWriter rateFile = new FileWriter(rateFileName);

            splotFileName = outputsFilePath + "/splots/" + NumOfVertices + "N" + initInfected + "p" + randomFileName + "Splot.txt";
            FileWriter splotFile = new FileWriter(splotFileName);

            startTimer = System.currentTimeMillis();


            for (int k = 0; k < (numOfIterations * discretization); k++) {
                verifyResultsFile = new FileWriter(verifyResultsFileName, true);
                statisticsFile = new FileWriter(statisticsFileName, true);
                plotFile = new FileWriter(plotFileName, true);
                tempDiscr++;
                cycle = k / discretization;
                System.out.println("Simulation Cycle: " + cycle);
                tempRate = 0;

                for (int i = 0; i < NumOfVertices; i++) {
                    nodeI = generalGraph.getVertex(i);
                    if ((nodeI.checkInfected()) && (nodeI.getIncubation() == 0)) {
                        for (int j = 0; j < NumOfVertices; j++) {
                            nodeJ = generalGraph.getVertex(j);
                            if (generalGraph.isAdjacent(nodeI, nodeJ)) {
                                randomSample = rgenerator.nextDouble();
                                if ((randomSample <=  (vita / discretization)) && (!nodeJ.checkInfected())) {
                                    //If an attacks is succesful we assume that is not loged
                                    nodeJ.setInfected();
                                    Simulation.decreaseNumberOfSusceptible();
                                    Simulation.increaseNumberOfInfected();
                                    nodeJ.setIncubation(1);
                                    System.out.println("Infection Succeded from Node " + i + " to Node " + j);
                                } else {
                                    vectorSize = nodeJ.getVectorSize();
                                    vectorPos = ((cycle) % vectorSize);
                                    //if fails to infect then log the attack
                                    if (!nodeJ.checkInfected()) nodeJ.logAttack(vectorPos);
                                }
                            }
                            vectorSize = nodeJ.getVectorSize();
                            vectorPos = ((cycle) % vectorSize);
                            nodeJ.calculateLRate(vectorPos);
                            //averageRate = tempRate / numOfVertices;
                        }
                            vectorSize = nodeJ.getVectorSize();
                            vectorPos = ((cycle) % vectorSize);
                            tempRate += nodeJ.calculateLRate(cycle);
                            averageRate = tempRate / numOfVertices;
                           {
                                //grate = nodeJ.calculateLRate(cycle);
                                //System.out.println("rate:= " + grate);
                           }
                    }

                }
                decreaseAllIncubation(generalGraph);
                System.out.println("-------------------------------------------------------------------------------------");

                intermediate = System.currentTimeMillis();
                duration = intermediate - startTimer;
                calculateElapsedTime(duration);

                avgRate += infectionRate;
                avgRate = avgRate / discretization;
                if (tempDiscr == discretization) {
                    writeData(randomFileName, cycle, infectionRate, averageRate, startTimer);
                    tempDiscr = 0;
                }
                
                System.out.println("num of inf= " + Simulation.getNumberOfInfected());
                System.out.println("infection rate=: " + (double) Simulation.getNumberOfInfected() / NumOfVertices);
                if (Simulation.getSelfdestruct()) {
                    System.exit(0);
                }
            }

            stoppedTimer = System.currentTimeMillis();
            duration = stoppedTimer - startTimer;
            calculateElapsedTime(duration);


            //checkVirusFile.close();
            statisticsFile.close();
            verifyResultsFile.close();
            //infectionProgressFile.close();
            plotFile.close();
            splotFile.close();
        } catch (IOException e) {
            System.out.println("I/O Exception " + e);
        }

    }




    /*
     *This method reads the graph that we created from BuildGraph class and returns it back to main
     */
    public static Graph getGraphTopology() throws IOException {
        String[] sa;
        Graph generalGraph = new Graph();

        try {
            FileReader f;
            BufferedReader br;
            StringTokenizer st;
            String s;
            int vertex1;
            int vertex2;
            int NumOfVertices;


            f = new FileReader("../GraphTopology.txt");
            br = new BufferedReader(f);

            while ((s = br.readLine()) != null) {
                if (s.startsWith("#")) {
                    if (s.indexOf("Nodes") != -1) {
                        //Create the info file
                        sa = s.split(" ");
                        NumOfVertices = (new Integer(sa[1]).intValue());

                        Simulation.setNumOfVertices(NumOfVertices);
                        System.out.println("Number of vertices \t" + Simulation.getNumOfVertices());
                        generalGraph = new Graph(Simulation.getNumOfVertices());
                    } else if (s.indexOf("Class") != -1) {
                        sa = s.split(" ");
                        classType = sa[1];
                    }
                } else {
                    st = new StringTokenizer(s);
                    vertex1 = Integer.parseInt(st.nextToken());
                    while (st.hasMoreTokens()) {
                        vertex2 = Integer.parseInt(st.nextToken());
                        generalGraph.addEdge(vertex1, vertex2);
                    }
                }
            }


            System.out.println("EOF");
            f.close();
            br.close();

        } catch (FileNotFoundException e) {
            System.err.println("Unable to find graph topology");

            System.exit(-1);
        }
        return generalGraph;
    }



    public static void main(String[] args) {
        String userInput2;
        String userInputSeed;
        String userInput0;
        String s;
        int m;
        int choice;
        int nodeIndex;
        int tempNode = -1;
        int lineCounter = 0;
        FileReader f;
        BufferedReader br;
        StringTokenizer st;
        Node nameOfNode;
        Date date;
        double v;

        try {

            f = new FileReader("../bin/config.txt");
            br = new BufferedReader(f);
            Graph generalGraph = getGraphTopology();

            System.out.println("Configuration file found - Parsing \n");
			System.out.println("<--Welcome to Promis(ing) Algorithm-->");
            while ((s = br.readLine()) != null) {
                System.out.print("*");
                ++lineCounter;
                st = new StringTokenizer(s);
                if (lineCounter == 1) {
                    seed = new Integer(st.nextToken()).intValue();
                    if (seed == -1) {
                        date = new Date();
                        seed = date.getTime();
                        rgenerator = new Random(seed);
                    } else
                        rgenerator = new Random(seed);
                } else if (lineCounter == 2) {
                    v = new Double(st.nextToken()).doubleValue();
                    Simulation.setVita(v);
                } else if (lineCounter == 3) {
                    m = new Integer(st.nextToken()).intValue();
                    Simulation.setMaxIterationNumber(m);
                } else if (lineCounter == 4) {
                    userInput2 = st.nextToken();
                    if (userInput2.equals("auto")) {
                        randomVirusFeeder(generalGraph);
                    } else if (userInput2.equals("semi")) {
                        s = br.readLine();
                        ++lineCounter;
                        st = new StringTokenizer(s);
                        numOfInitialInfected = new Integer(st.nextToken()).intValue();
                        semiRandomVirusFeeder(generalGraph, numOfInitialInfected);
                    } else if (userInput2.equals("manual")) {
                        s = br.readLine();
                        ++lineCounter;
                        st = new StringTokenizer(s);
                        numOfInitialInfected = new Integer(st.nextToken()).intValue();
                        s = br.readLine();
                        ++lineCounter;
                        sa = s.split(" ");
                        if (sa.length != numOfInitialInfected) {
                            System.out.println("Different number of preinfected nodes, than actually parsed");
                            System.out.println("Found: " + sa.length + " Expected: " + numOfInitialInfected);
                            System.out.println("Exiting");
                            System.exit(-1);
                        }

                        for (int i = 0; i < sa.length; i++) {
                            nodeIndex = new Integer(sa[i]).intValue();
                            if (tempNode >= nodeIndex) {
                                System.out.println("Arrange nodes in the correct order");
                                System.exit(-1);
                            }
                            tempNode = nodeIndex;
                            nameOfNode = generalGraph.getVertex(nodeIndex);
                            nameOfNode.setInfected();
                            Simulation.decreaseNumberOfSusceptible();
                            Simulation.increaseNumberOfInfected();
                            //System.out.println("Preinfected node=:\t" + nameOfNode);
                            System.out.println("Preinfected node=:\t" + nodeIndex);
                        }
                    }
                }
            }

            try {
                Thread.currentThread().sleep(10000);
            } catch (InterruptedException ie) {
                System.out.println("Thread messed up");
            }
            coreSusceptibleImmuneSimulationEngine(generalGraph);

        } catch (FileNotFoundException fnfe) {
            try {
                Graph generalGraph = getGraphTopology();
                System.out.println("Configuration file not found");
                System.out.println("Please enter the seed");
                userInputSeed = SimpleIO.readLine();
                seed = Integer.parseInt(userInputSeed);
                rgenerator = new Random(seed);

                SimpleIO.prompt("Please specify birth rate:  ");
                userInput0 = SimpleIO.readLine();
                v = Double.parseDouble(userInput0);
                Simulation.setVita(v);
                System.out.println("Bith rate specified ");

                SimpleIO.prompt("Please specify maximum iteration number: ");
                String maxItermation = SimpleIO.readLine();
                m = Integer.parseInt(maxItermation);
                Simulation.setMaxIterationNumber(m);

                Simulation.setEnviromentaltIncubation(1);
                System.out.println("Setting Incubation to " + incubation);

                System.out.println("****Virus feeder parameters:****");
                System.out.println("1.Define manually initially infected nodes ");
                System.out.println("2.Define only the number of the initially infected nodes and let Piranha randomly select them");
                System.out.println("3.Random selection of the initialy infected nodes");
                System.out.println();
                System.out.println("Please enter one of the above numbers");
                userInput2 = SimpleIO.readLine();
                choice = Integer.parseInt(userInput2);
                if (choice == 1)
                    virusFeeder(generalGraph);
                else if (choice == 2)
                    semiRandomVirusFeeder(generalGraph, numOfInitialInfected);
                else if (choice == 3)
                    randomVirusFeeder(generalGraph);
                else {
                    System.out.println("Your entry was invalid!");
                    System.out.println("Please enter one of the above numbers");
                }
                coreSusceptibleImmuneSimulationEngine(generalGraph);
            } catch (IOException ioe) {
                System.out.println("I/O Exception in FNF Exception");
            }
        } catch (IOException e) {
            System.err.println("I/O Exception" + e);
        }
    }
}
